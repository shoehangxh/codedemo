# 第十五章

## 异常处理

- 用于处理程序在调用过程中的非正常行为（调用）

  - 传统的处理方法：传返回值表示函数调用是否正常结束（正常return 0， 否则返回return 1）

    存在很多问题，降低程序性能

  - C++中的方法：通过关键字try/catch/throw 引入异常处理机制

    ```c++
    void f1()
    {
        int x;//之后会销毁f2
        int y;//先被销毁
        throw 1; //抛出异常，无需考虑更改返回值类型
        std::cout << '1' ;//不会执行
    }
    void f2()
    {
        f1();
    }
    void f3()
    {
        f2();
    }
    
    int main()
    {
        try{
            f3(); //异常处理逻辑
        }
        catch(int e) //接住 throw 1 此时e = 1
        {
            std::cout << "123" << std::endl;
        }
        
    }
    ```

  - 异常触发的系统行为：栈展开

    - 抛出异常后续的代码就不会执行了
    - 局部对象会按照**构造相反**的顺序自动销毁（从下往上销毁）
    - 再尝试匹配catch代码
      - 只会匹配一个catch，且会继续执行catch之后的逻辑（停止栈展开）
      - 如果匹配不成功，则继续展开main函数，指导运行至terminate结束运行。

  - 异常对象 （catch（int e））

    - 系统会缺省生成一个异常对象（catch （int））
    - 异常对象会始终在栈展开过程中被保留，并最终传递给匹配的catch语句

  - try / catch 语句块

    - 一个try后面可以跟多个catch，用于catch多种异常对象
    - catch语句块从上到下顺序执行（相同的类型会被上面的覆盖）
    - 使用catch(...)匹配任意类型的异常（）一般放在捕获位置的最后
    - 在catch中调用throw继续抛出相同的异常

  - 在一个异常未处理完成时抛出新的异常会导致程序崩溃

    - 不要在析构函数中抛出异常（抛出异常时会销毁前序变量，销毁的时候还有异常）或operator delete等重构函数中
    - 通常来说，catch接收的类型为引用类型（抛出一个对象类型，因为异常对象是一个拷贝初始化的操作，但拷贝初始化中可能会有异常抛出）

- 异常与构造，析构函数

  - 使用function-try-block保护初始化逻辑
    - 在构造函数初始化列表处（也可以不写使用缺省初始化列表）进行try（但此时构造失败，会隐式再加一个throw继续抛出异常，否则后续对于构造失败对象的所有逻辑都是未定义的，程序不安全）
    - 一般用于构造函数，但也可以放到一般意义的函数中，但不会隐式加throw，后续可能会有问题
    - 在构造函数中抛出异常，构造的对象会被销毁，（还没被调用的结构体析构函数显然不会被调用），而且析构函数（类的）不会被调用

- 描述函数**是否**会抛出异常

  - 如果表明（明示）函数不会抛出异常，则表明为系统提供更多的优化空间

    - C++ 98方式： throw（）  /  throw（int ，char） //加在函数列表（小括号）之后，前面表示不抛出，后面表示可能会抛出（什么类型的异常）
    - C++ 11之后的改进： noexcept  / noexcept(false)  //加在函数列表（小括号）之后，前面表示不抛出，后面表示可能会抛出（此时将类型信息转移到运行期）

  - noexcept

    - 限定符：接收false 、 true（缺省）表示是否会抛出异常

    - 操作符：接收一个表达式，根据表达式**是否可能抛出异常**返回 false/ true

      noexcept(fun())  //看这个fun函数会不会抛出异常，一般与限定符的一致，可以用于加在限定符的括号中，表示嵌套关系

    - 在声明了noexcept（true）的函数中，使用throw抛出异常，会有warning，但不会报错，此时无论后面有没有catch，都会抛出terminate终止崩溃

    - 不作为函数重载依据（改变之后也是一个函数），但使用函数指针（后面noexcept形式要加上，且保持一致），虚拟函数重写时要保持形式兼容。

- 标准库中提供的异常类型（throw后面加的类型）

  - 正确对待异常处理
    - 不要滥用：异常的执行成本非常高
    - 不要不用：对于真正的异常场景，异常处理是相对高效，简洁的方式
    - 编写异常 安全的代码

