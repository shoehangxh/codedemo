# 第十五章

## 异常处理

- 用于处理程序在调用过程中的非正常行为（调用）

  - 传统的处理方法：传返回值表示函数调用是否正常结束（正常return 0， 否则返回return 1）

    存在很多问题，降低程序性能

  - C++中的方法：通过关键字try/catch/throw 引入异常处理机制

    ```c++
    void f1()
    {
        int x;//之后会销毁f2
        int y;//先被销毁
        throw 1; //抛出异常，无需考虑更改返回值类型
        std::cout << '1' ;//不会执行
    }
    void f2()
    {
        f1();
    }
    void f3()
    {
        f2();
    }
    
    int main()
    {
        try{
            f3(); //异常处理逻辑
        }
        catch(int e) //接住 throw 1 此时e = 1
        {
            std::cout << "123" << std::endl;
        }
        
    }
    ```

  - 异常触发的系统行为：栈展开

    - 抛出异常后续的代码就不会执行了
    - 局部对象会按照**构造相反**的顺序自动销毁（从下往上销毁）
    - 再尝试匹配catch代码
      - 只会匹配一个catch，且会继续执行catch之后的逻辑（停止栈展开）
      - 如果匹配不成功，则继续展开main函数，指导运行至terminate结束运行。

  - 异常对象 （catch（int e））

    - 系统会缺省生成一个异常对象（catch （int））
    - 异常对象会始终在栈展开过程中被保留，并最终传递给匹配的catch语句

  - try / catch 语句块

    - 一个try后面可以跟多个catch，用于catch多种异常对象
    - catch语句块从上到下顺序执行（相同的类型会被上面的覆盖）
    - 使用catch(...)匹配任意类型的异常（）一般放在捕获位置的最后
    - 在catch中调用throw继续抛出相同的异常

  - 在一个异常未处理完成时抛出新的异常会导致程序崩溃

    - 不要在析构函数中抛出异常（抛出异常时会销毁前序变量，销毁的时候还有异常）或operator delete等重构函数中
    - 通常来说，catch接收的类型为引用类型（抛出一个对象类型，因为异常对象是一个拷贝初始化的操作，但拷贝初始化中可能会有异常抛出）

- 异常与构造，析构函数

  - 使用function-try-block保护初始化逻辑
    - 在构造函数初始化列表处（也可以不写使用缺省初始化列表）进行try（但此时构造失败，会隐式再加一个throw继续抛出异常，否则后续对于构造失败对象的所有逻辑都是未定义的，程序不安全）
    - 一般用于构造函数，但也可以放到一般意义的函数中，但不会隐式加throw，后续可能会有问题
    - 在构造函数中抛出异常，构造的对象会被销毁，（还没被调用的结构体析构函数显然不会被调用），而且析构函数（类的）不会被调用

- 描述函数**是否**会抛出异常

  - 如果表明（明示）函数不会抛出异常，则表明为系统提供更多的优化空间

    - C++ 98方式： throw（）  /  throw（int ，char） //加在函数列表（小括号）之后，前面表示不抛出，后面表示可能会抛出（什么类型的异常）
    - C++ 11之后的改进： noexcept  / noexcept(false)  //加在函数列表（小括号）之后，前面表示不抛出，后面表示可能会抛出（此时将类型信息转移到运行期）

  - noexcept

    - 限定符：接收false 、 true（缺省）表示是否会抛出异常

    - 操作符：接收一个表达式，根据表达式**是否可能抛出异常**返回 false/ true

      noexcept(fun())  //看这个fun函数会不会抛出异常，一般与限定符的一致，可以用于加在限定符的括号中，表示嵌套关系

    - 在声明了noexcept（true）的函数中，使用throw抛出异常，会有warning，但不会报错，此时无论后面有没有catch，都会抛出terminate终止崩溃

    - 不作为函数重载依据（改变之后也是一个函数），但使用函数指针（后面noexcept形式要加上，且保持一致），虚拟函数重写时要保持形式兼容。

- 标准库中提供的异常类型（throw后面加的类型）

  - 正确对待异常处理
    - 不要滥用：异常的执行成本非常高
    - 不要不用：对于真正的异常场景，异常处理是相对高效，简洁的方式
    - 编写异常 安全的代码

## 枚举与联合

- 枚举（enum）：一种取值有限的特殊类型，翻译单元级（一个cpp文件）的一次定义

  ```c++
  enum Color
  {
      Red,
      Green,
      Yellow
  };
  
  int main()
  {
      Color x = Red;  //取值受限的类型
      std::cout << x <<std::endl; //0
      Color y = Green; 
      std::cout << y <<std::endl; //1
  }
  ```

  

  - 分为无作用域枚举（虽然引入了大括号，但作用域不在color，而是属于包含color的作用域）和有作用域枚举（C++11开始，需使用关键字 enum class Color{}， 此时color就是一个独立域，用于规避可能产生的名字污染（同域内不能重复定义））
  - 枚举项缺省使用0初始化，依次递增（0,1,2）【如果使red = 100，那么之后也是以100为基础再依次递增】，如果定义两者赋值相同也是可以的，此时重新计数，也可以用常量表达式定义（black = red+ green... ）编译期常量，但（有作用域枚举）定义的时候必须定义red，不能定义100（color x = 100，但可以显式转换color x = `stastic_cast <color>(100)`）(无作用域枚举项是可以隐式转化的)
  - 可以为枚举指明类型（enum Color : char），以定义缺省值长度（此时为1）
  - 注意区分枚举的定义与声明（enum color； // 无作用域这样声明是不行的，因为不知道底层分配内存大小，有作用域声明缺省是int，可以使用这种方法进行声明）

- 联合（union）：将多个类型合并到一起以节省空间（所有的元素在同一时间只有一个会发生作用）

  ```c++
  struct Str{
      int x;
      int y;
  };
  union Str1{
      int x;
      int y;
  };
  int main()
  {
      std::cout << sizeof(Str) <<std::endl; //8
      std::cout << sizeof(Str1) <<std::endl; //4（如果有不同类型，以占用最大为准）
      Str1 obj;
      obj.x = 100;
      std::cout << obj.y <<std::endl; //100(联合是同时修改，如果是char int之间可能会发生ascII码转换)
  }
  
  ```

  

  - 通常与枚举一起使用（相关类型放到结构体中）
  - 匿名联合（简化代码编写）
  - 在联合中包含非内建类型（C++11起）（union里面不能包含std::string等）

## 嵌套类与局部类

- 嵌套类：在类中定义类

  ```c++
  class out
  {
  public:
      class in
      {
          inline static int val = 3;
      };
  };
  int main()
  {
      out::in obj;
      out::in::val;
  }
  ```

  

  - 嵌套类拥有自己的域，与外围类形成嵌套关系
    - 嵌套类中的名称查找失败是会在外围类中继续查找（但必须在前面，打破这种顺序关系是定义成员函数，此时是两遍处理原则）
  - 嵌套类与外围类单独拥有各自的成员（外围类不能调用内层类的成员，反之亦然）

- 局部类：在函数内部定义的类（结构体）

  - 不放到外面的原因是避免可能的名称污染
  - 可以访问外围函数中定义的类型声明，静态对象与枚举
  - 局部类可以定义成员函数，但成员函数的定义必须位于类内部（外部的函数中也可以使用），原因是函数内不能定义函数
  - 局部类不能定义静态数据成员（inline static int val = 100；应该放到函数外部单独定义）

## 嵌套名字空间与匿名名字空间

- 嵌套名字空间（类似于类的嵌套）
  - 名字空间可以嵌套，嵌套名字空间形成嵌套域
  - 注意**同样的名字空间定义**可以出现在程序多处，以向同一个名字空间中**增加**声明或定义
  - C++17开始可以**简化**嵌套名字空间的定义（多层名字空间，缩进造成代码不易读，简化：namespace out::in {}  此时形成嵌套）
- 匿名名字空间
  - 直接 namespace { int y；} 不会形成域。可以直接访问
  - 用于构造仅翻译单元可见的对象，没有外部链接（外部无法访问，多个cpp之间不会冲突）
  - 可以使用static代替
  - 可作为嵌套名字空间，此时只需要加上外围的名字即可，但此时仍没有外部链接，多个cpp不会冲突

## 位域与volatile关键字

- 位域：显示表明对象尺寸（所占位数）？位

  ```c++
  struct A 
  {
      bool b1 :1 ; //改成1位
      bool b2 :1 ;
  };
  int main()
  {
      std ::cout << sizeof(A) <<std::endl;  //(2) 1
  }
  ```

  

  - 在结构体、类中使用（付出运算时间，以节省内存，可能会降低程序运行效率）
  - 多个位域对象可能会被打包存取
  - 声明了位域的对象无法取地址，无法使用指针和非const引用进行绑定（const引用会创建一个临时量进行绑定）
  - 尺寸通常会小于对象类型对应的尺寸（bool类型通常不会赋值位域1以上），否则取值会受到限制（不会超过，额外的位会选择不填充）

- volatile关键字

  - 表明一个对象可能会被当前程序以外的程序修改（对象每一次读取都要从内存读取，不能直接从缓存中读取，因为内存中的对象可能已经被另一程序改写）
  - 响应对象的读写可能会加重程序的负担（多线程时可能会使用）
  - 注意慎重使用---一些情况可以使用atomic代替（一般都不会使用）

