# 第十一章 类与面向对象编程

## 结构体与对象聚合

- 结构体：对基本数据结构进行扩展，将多个对象放置在一起视为一个整体

  结构体需要加分号，可可以赋予结构别名 typedef () +别名；

  仅有声明的结构体是不完全类型 （struct Str;）无法定义Str，但可以使用Str* （Str* x是合法的）

  结构体（以及类）的一处定义原则：翻译单元级别（不同的cpp文件可以重复定义）

- 数据成员（数据域）的声明与初始化（结构体中间定义的变量）
  - （C++ 11）结构体的定义包含的数据成员是声明（不是定义，或可理解为隐式定义）数据成员可以使用decltype声明其类型（decltype（3） x）不能用auto
  - 可以加入const 引用等限定
  - （C++11起）类内成员初始化，定义的同时就初始化
  - 聚合初始化：结构体中未赋值的数据成员会默认缺省值 Str m_str{3} ({3,4}) 20起引入一个指定初始化（给出名字，x  =，， y = ，，，（类似python））
  - 定义结构体使用const（main中），里面的对象不能改变，那可以在这个对象前加一个mutable（结构体中）const和mutable的位置不能改
  
- 静态数据成员--多个对象之间共享的数据成员
  - Str x1; Str x2两个对象，对x1中数据的修改不会改变x2中的数据
  - 声明静态数据成员（结构体中）static int x ；并在结构体外 int Str::x（代表x的所在域）;
  - 定义方式的演化：
    - C++98: 类内声明，类外初始化，结构体声明可以在头文件，但是要在具体的cpp文件中再定义（int Str::x）（所有cpp定义一次就可，否则会在链接时出错，如果要求这个数值在编译期确定（比如数组大小），那需要在定义的时候 const static int xx = 100）
    - C++17:内联静态成员初始化 inline const static int x = 100；或inline static int x = 100（甚至可以修改）
  - 可以使用auto推导静态数类型inline static auto x = 100（只支持**静态数据成员**）
  
- 静态数据成员的访问：
  - 使用. ->
  - ::操作符
  
- 在类的内部声明相同类型的数据成员 在Str内嵌套Str 要用static Str x；（但此时只是声明，没有定义，定义，在另一个cpp或结构体外 Str Str::x;  不能使用inline类型在结构体外定义。但是可以在结构体外 inline Str Str::x;定义可以避免在头文件中，多次引入造成重复定义）

## 成员函数（方法）

- 可以在结构体中定义函数，作为成员的一部分：对内操作数据成员（抽象数据类型），对外提供调用接口

  struct STR{ int x  = 3;  void fun() {std::cout << x <<std::endl; }}  //无需显式传入形参

  int main() {STR x; x.fun()} // 3

  - 在结构体中将数据相关的成员函数组合在一起将形成类，是C++在C基础上引入的概念
  - 关键字 class （struct 变成 class 第一行加一个 public：）
  - 类可以是为一种抽象数据类型。类本身形成域，成为类域

- 类的声明与定义

  - 类内定义（隐式内联） // 不会在多个cpp的头文件中出现重复定义
  - 类内声明，类外定义（类内只写到 void fun();  在外面定义 void Str::fun() { ... }）//第二个外面定义的函数不再是内联的，可以加一个 inline void... ，这样作为接口，更加简洁
  - 类与编译期的两遍处理 ：一般会把函数放到前面，但会导致有些变量还没声明，因此第一次不会具体处理函数逻辑（也因此不能直接不按顺序调用函数，因为这个时候函数可能没有定义）
  - 成员函数与尾随返回类型（trail-returning type），类内定义的函数类型，在外面也要加域限定符，或用auto自动推到 后面加 —>函数类型名

- 成员函数与 this 指针

  - 使用this指针引用当前对象 （在str中用fun方法打印this指针，那么打印的this指针就是实例化结构体的地址，或理解为里面的fun函数会默认传入一个指针 // Str* this，这个时候传入的形参x，和this指向的x不是同一个)
  - 基于const的成员函数重载， ：this指针是const 的，指针本身不能修改（指向的内容是可以修改的），要想防止指针的内容被修改，可以在函数（）后面加一个 const

- 成员函数的名称查找与隐藏关系

  - 函数内部（包括形参名称）会隐藏函数外部的同名变量（可以用this/Str::调用外部的名称）
  - 类内名称也隐藏了类外名称（类外定义的函数，里面的参数也是类内的）
  - 使用this或域操作符引入依赖型名称查找（更多的限定）

- 静态成员函数

  - 在静态成员函数返回静态数据成员，也就是说这个函数前面有static，里面的所有参数也都应该是static
  - 好处是不一定要实例化结构体，可以直接访问结构体内部的函数
  - 此时变量所需内存会在程序运行期建立，因此vector等变量会出现一些问题，但是可以把vector定义在函数体内，这样只有函数被使用，才会调用这个变量。
  - 单例模式：函数内 再static STR x; return x;

- 成员函数基于引用限定符的重载（C++ 11）

  void foo() & //左值引用

  void foo() &&  //右值引用（可以被修改）

  void foo() const &

  void foo() const &&

## 访问限定符与友元

- 使用 public / private/ protected进行成员限制访问

  private: 后面的变量不能在作用域以外进行访问；（public后面的则可以）

  protected：不能进行继承（也不能在作用域以外访问）

  类与结构体缺省访问权限有区别（class默认private， struct默认public）

  意义：便于进行抽象数类型的**封装**（统一化，只把部分代码进行private等的区分）

- 使用友元打破访问权限限制 -- 关键字friend 

  - **声明**某个类或某个函数是当前类的友元--慎用！（打破了封装，产生副作用）（只能自己授权给别人，可以放在授权类的任意位置）

    先声明 int main();   在class里面 { friend int main(); } //此时main可以访问私有成员函数

  - 在类内首次声明友元**类**或友元**函数**   （在后面的函数可以先不用声明，使代码简洁，把友元那句看作函数声明，因此在函数前不能加::（全局函数））

    - 注意使用限定名称引入友元并非友元类（友元函数）的声明

  - 友元函数的类内定义与类内外定义

  - 隐藏友元（hidden friend）:在类内进行函数的定义，前面加friend后，则是友元函数，作用域位于全局域。但仍然在main里无法调用，因为看作是一个隐藏友元(如果函数有某种类型的实参，仍然可以找到这个隐藏友元)

    - 好处：减轻编译器负担，防止误用
    - 改变隐藏友元的缺省行为：在类外声明(或定义)函数

## 构造、析构与复制成员函数

- 构造函数：

  - 名称与类 名相同，无返回值，可以包含多个版本（重载）

    class str{

    public:

      str(){ }

    };  //main中实例化类的时候会自动执行构造函数（如str m;）

  - C++11: 代理构造函数

     str(){ }   -- > str() : str(3) {}  //代理，此时接受一个形参值3（后面要有一个接受实参的函数str（int input） // 此时先执行后面的代理函数，再执行当前函数）

- 初始化列表：

  - 构造的同时直接初始化 会提升系统性能
  - 使用方法：str（string val）: x(val)  //直接使用传入的val进行x的初始化 也可以用逗号， 直接初始化多个形参
  - 一些情况下必须使用初始化列表（类中包含引用成员） //因为构造引用的时候值必须初始化（也就是说类内的数据成员定了一个引用，在构造函数里还要对这个引用进行赋值）
  - 注意元素的初始化顺序与其声明顺序相关，与初始化列表的顺序（冒号后的顺序）无关，也就是**初始化的时候按照后面声明的顺序**，（后构造的对象先销毁）
  - 使用初始化列表**覆盖**类内成员初始化行为

- 缺省构造函数：不需要提供时机参数就可以调用的构造函数（只有一个括号的就是）

  - 如果类中没有任何一个构造函数，类内会自动合成一个缺省构造函数（条件允许的情况下：如果有一个不同类型的构造函数则不行，或者里面有引用，因为不能合成缺省构造函数对一个引用进行缺省初始化）
  - 缺省构造函数会对参数值进行缺省初始化
  - 使用缺省构造函数时应避免  most vexing parse
  - 使用default关键字定义缺省构造函数  Str（） = default；// 自动的缺省值，适用于有一个其他不同的缺省构造函数而编译器不会自己合成缺省构造函数

## 字面值类，成员指针与bind交互

- 字面值类：可以构建编译期常量的类型（constexpr int a = 3）//对应于运行期，后者可以进行更改
  - 其数据成员需要是字面值类型（constexpr Str a （Str里面都要属于字面值类型（int可以，std::string就不是字面值类型）））
  - 提供constexpr/consteval构造函数（小心使用consteval C++20起，consteval只能在编译期使用，写在构造函数关键字最前，不能传入一个运行期或可能是运行期的变量（int），但是constexpr可以）
  - 平凡的析构函数：~Str（） = default //        不能是~Str() {} //运行期才会执行，所以不能引入任何销毁的逻辑
  - 提供constexpr/ consteval的成员函数（也是写在最前面，最后面加一个const（C++11之前会有一个缺省的const，代价是里面只能包含一个return语句，C++14起就不行了，不再是const成员函数），函数中的逻辑会在编译期完成，consteval的话所对应的构造函数也必须是consteval型）

- 成员指针：(只需要对结构体进行声明即可)
  - 数据成员指针类型： int A::*ptr; // A是结构体名，星号前面所有的东西是指针类型，（不是int型）
  - 函数成员指针类型：int (A::*)(double); // void (Str:: * ptr_fun)();
  - 成员指针对象赋值： auto ptr = &A::x;// auto可以是前面的两个指针类型，A中有一个public的int x，但是函数成员指针类型不能使用auto（如果有函数重载的情况下（有两个同名函数）），而且不能写成&(A::x);除非A::x有具体意义
  - 成员指针对象是不支持相减的
  -   `int Str:: *ptr = &Str::x; Str obj ; obj.x = 3; cout << obj.*ptr <<endl ;  // 3`  左操作数是对象指针要是用->, 是对象要用.
- bind交互
  - 使用bind+成员指针构造可调用对象
