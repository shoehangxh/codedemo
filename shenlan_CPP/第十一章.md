# 第十一章 类与面向对象编程

## 结构体与对象聚合

- 结构体：对基本数据结构进行扩展，将多个对象放置在一起视为一个整体

  结构体需要加分号，可可以赋予结构别名 typedef () +别名；

  仅有声明的结构体是不完全类型 （struct Str;）无法定义Str，但可以使用Str* （Str* x是合法的）

  结构体（以及类）的一处定义原则：翻译单元级别（不同的cpp文件可以重复定义）

- 数据成员（数据域）的声明与初始化（结构体中间定义的变量）
  - （C++ 11）结构体的定义包含的数据成员是声明（不是定义，或可理解为隐式定义）数据成员可以使用decltype声明其类型（decltype（3） x）不能用auto
  - 可以加入const 引用等限定
  - （C++11起）类内成员初始化，定义的同时就初始化
  - 聚合初始化：结构体中未赋值的数据成员会默认缺省值 Str m_str{3} ({3,4}) 20起引入一个指定初始化（给出名字，x  =，， y = ，，，（类似python））
  - 定义结构体使用const（main中），里面的对象不能改变，那可以在这个对象前加一个mutable（结构体中）const和mutable的位置不能改
  
- 静态数据成员--多个对象之间共享的数据成员
  - Str x1; Str x2两个对象，对x1中数据的修改不会改变x2中的数据
  - 声明静态数据成员（结构体中）static int x ；并在结构体外 int Str::x（代表x的所在域）;
  - 定义方式的演化：
    - C++98: 类内声明，类外初始化，结构体声明可以在头文件，但是要在具体的cpp文件中再定义（int Str::x）（所有cpp定义一次就可，否则会在链接时出错，如果要求这个数值在编译期确定（比如数组大小），那需要在定义的时候 const static int xx = 100）
    - C++17:内联静态成员初始化 inline const static int x = 100；或inline static int x = 100（甚至可以修改）
  - 可以使用auto推导静态数类型inline static auto x = 100（只支持**静态数据成员**）
  
- 静态数据成员的访问：
  - 使用. ->
  - ::操作符
  
- 在类的内部声明相同类型的数据成员 在Str内嵌套Str 要用static Str x；（但此时只是声明，没有定义，定义，在另一个cpp或结构体外 Str Str::x;  不能使用inline类型在结构体外定义。但是可以在结构体外 inline Str Str::x;定义可以避免在头文件中，多次引入造成重复定义）

## 成员函数（方法）

- 可以在结构体中定义函数，作为成员的一部分：对内操作数据成员（抽象数据类型），对外提供调用接口

  struct STR{ int x  = 3;  void fun() {std::cout << x <<std::endl; }}  //无需显式传入形参

  int main() {STR x; x.fun()} // 3

  - 在结构体中将数据相关的成员函数组合在一起将形成类，是C++在C基础上引入的概念
  - 关键字 class （struct 变成 class 第一行加一个 public：）
  - 类可以是为一种抽象数据类型。类本身形成域，成为类域

- 类的声明与定义

  - 类内定义（隐式内联） // 不会在多个cpp的头文件中出现重复定义
  - 类内声明，类外定义（类内只写到 void fun();  在外面定义 void Str::fun() { ... }）//第二个外面定义的函数不再是内联的，可以加一个 inline void... ，这样作为接口，更加简洁
  - 类与编译期的两遍处理 ：一般会把函数放到前面，但会导致有些变量还没声明，因此第一次不会具体处理函数逻辑（也因此不能直接不按顺序调用函数，因为这个时候函数可能没有定义）
  - 成员函数与尾随返回类型（trail-returning type），类内定义的函数类型，在外面也要加域限定符，或用auto自动推到 后面加 —>函数类型名

- 成员函数与 this 指针

  - 使用this指针引用当前对象 （在str中用fun方法打印this指针，那么打印的this指针就是实例化结构体的地址，或理解为里面的fun函数会默认传入一个指针 // Str* this，这个时候传入的形参x，和this指向的x不是同一个)
  - 基于const的成员函数重载， ：this指针是const 的，指针本身不能修改（指向的内容是可以修改的），要想防止指针的内容被修改，可以在函数（）后面加一个 const

- 成员函数的名称查找与隐藏关系

  - 函数内部（包括形参名称）会隐藏函数外部的同名变量（可以用this/Str::调用外部的名称）
  - 类内名称也隐藏了类外名称（类外定义的函数，里面的参数也是类内的）
  - 使用this或域操作符引入依赖型名称查找（更多的限定）

- 静态成员函数

  - 在静态成员函数返回静态数据成员，也就是说这个函数前面有static，里面的所有参数也都应该是static
  - 好处是不一定要实例化结构体，可以直接访问结构体内部的函数
  - 此时变量所需内存会在程序运行期建立，因此vector等变量会出现一些问题，但是可以把vector定义在函数体内，这样只有函数被使用，才会调用这个变量。
  - 单例模式：函数内 再static STR x; return x;

- 成员函数基于引用限定符的重载（C++ 11）

  void foo() & //左值引用

  void foo() &&  //右值引用（可以被修改）

  void foo() const &

  void foo() const &&

## 访问限定符与友元

- 使用 public / private/ protected进行成员限制访问

  private: 后面的变量不能在作用域以外进行访问；（public后面的则可以）

  protected：不能进行继承（也不能在作用域以外访问）

  类与结构体缺省访问权限有区别（class默认private， struct默认public）

  意义：便于进行抽象数类型的**封装**（统一化，只把部分代码进行private等的区分）

- 使用友元打破访问权限限制 -- 关键字friend 

  - **声明**某个类或某个函数是当前类的友元--慎用！（打破了封装，产生副作用）（只能自己授权给别人，可以放在授权类的任意位置）

    先声明 int main();   在class里面 { friend int main(); } //此时main可以访问私有成员函数

  - 在类内首次声明友元**类**或友元**函数**   （在后面的函数可以先不用声明，使代码简洁，把友元那句看作函数声明，因此在函数前不能加::（全局函数））

    - 注意使用限定名称引入友元并非友元类（友元函数）的声明

  - 友元函数的类内定义与类内外定义

  - 隐藏友元（hidden friend）:在类内进行函数的定义，前面加friend后，则是友元函数，作用域位于全局域。但仍然在main里无法调用，因为看作是一个隐藏友元(如果函数有某种类型的实参，仍然可以找到这个隐藏友元)

    - 好处：减轻编译器负担，防止误用
    - 改变隐藏友元的缺省行为：在类外声明(或定义)函数

## 构造、析构与复制成员函数

- 构造函数：

  - 名称与类 名相同，无返回值，可以包含多个版本（重载）

    class str{

    public:

      str(){ }

    };  //main中实例化类的时候会自动执行构造函数（如str m;）

  - C++11: 代理构造函数

     str(){ }   -- > str() : str(3) {}  //代理，此时接受一个形参值3（后面要有一个接受实参的函数str（int input） // 此时先执行后面的代理函数，再执行当前函数）

- 初始化列表：

  - 构造的同时直接初始化 会提升系统性能
  - 使用方法：str（string val）: x(val)  //直接使用传入的val进行x的初始化 也可以用逗号， 直接初始化多个形参
  - 一些情况下必须使用初始化列表（类中包含引用成员） //因为构造引用的时候值必须初始化（也就是说类内的数据成员定了一个引用，在构造函数里还要对这个引用进行赋值）
  - 注意元素的初始化顺序与其声明顺序相关，与初始化列表的顺序（冒号后的顺序）无关，也就是**初始化的时候按照后面声明的顺序**，（后构造的对象先销毁）
  - 使用初始化列表**覆盖**类内成员初始化行为

- 缺省构造函数：不需要提供时机参数就可以调用的构造函数（只有一个括号的就是）

  - 如果类中没有任何一个构造函数，类内会自动合成一个缺省构造函数（条件允许的情况下：如果有一个不同类型的构造函数则不行，或者里面有引用，因为不能合成缺省构造函数对一个引用进行缺省初始化）
  - 缺省构造函数会对参数值进行缺省初始化
  - 使用缺省构造函数时应避免  most vexing parse
  - 使用default关键字定义缺省构造函数  Str（） = default；// 自动的缺省值，适用于有一个其他不同的缺省构造函数而编译器不会自己合成缺省构造函数

- 单一参数构造函数

  - str m = 3 //隐式类型转换 int转化为str （对应str的构造函数借口）

    如果希望编译期不发生隐式类型转换：在结构体对应构造函数前加一个 explicit 这样需要str m（3）/ str m{3} / str m = str(3) / str m = static_cast< str> (3)  才可以调用构造函数

- 拷贝构造函数：接受一个当前类对象的构造函数

  - 构造函数的形式 str (const str& x)  : val(x.val) {}   private: int val = 3;  //但此时编译器会报错，需要引入一个str() = default ，第一个形参列表必须是传一个引用; 
  - 调用 str m ； str m2 = m //此时拷贝构造函数会被调用
  - 编译器会自动合成str (const str&) = default  //前面也要加一个str（） = default ，合成的版本会依次对每个数据成员进行拷贝构造

- 移动构造函数 （C++11）：接受一个当前类**右值引用对象**(不能是const，只有右值引用可以被偷取)的构造函数（进一步提升系统的性能）

  - 应用时：str m； str m2 = std::move(m) //需要调用移动构造函数

  - str（str &&  x）: val (x.val), a (std::move(x.a)) （a被偷去）

  - 保证偷窃对象之后，传入对象是合法的

  - 当某些特殊函数（拷贝构造）未定义时，编译器会合成一个

    str（str && ） = default ；//数据成员引入一个新的类，（default时）也要对这个类进行移动（在新的类里面）有移动调移动，没有移动调拷贝

  - 通常声明为不可抛出异常的函数

    str（str && ）noexcept = default；//避免引入编译器额外附加的一系列异常逻辑，导致性能下降

  - 注意右值引用对象用做表达式时是左值（访问的是地址）

- 拷贝赋值和移动赋值函数（operator=）// 运算符重载

  - str m; str m1; m = m1; // 赋值操作

  - 类内的操作： str& operator= (const str&x) { ... ; return *this} // 拷贝赋值函数

  - 注意赋值函数不能使用初始化列表

  - 通常来说返回值是当前类型的引用 （重载的=不会改变其本身的结合性，不返还引用就无法进行连等操作）

  - str& operator= (str&&x) //移动赋值运算

  - 注意处理给自身赋值 m = std::move(m) //会有一些复杂的问题

    if （&x == *this）{return *this}

  - 编译器在一定情况下可以自动合成（拷贝赋值）

- 析构函数（反构造）

  - 函数名：“~”加当前类型，无参数，无返回值
  - 用于释放资源 ~str() {}  //对象销毁时会被调用
  - 内存回收是在调用析构函数之后才会执行（析构函数只是会销毁对象，没有针对内存）
  - 也可以自动合成
  - 一般不会抛出异常使用 noexcept

- 通常来说，一个类需要：

  - 需要定义析构函数，那么也需要定义拷贝构造与拷贝赋值函数
  - 如果需要定义拷贝构造函数，那么也需要定义拷贝赋值函数
  - 如果需要定义拷贝构造（赋值）函数，那么也要考虑定义移动构造（赋值）函数

- 实例：包含指针的类

- default关键字

  - 只对特殊成员函数有效

- delete关键字

  - 对所有函数都有效
  - 注意其与未声明的区别（直接令函数 = delete（把函数声明成delete），不调用不没问题，调用会出错），意思是不允许调用，但声明还在，所以不会再class中合成缺省构造函数
  - 不要为移动构造（赋值）引入delete限定符
    - 如果只需要拷贝，那么引入拷贝构造即可
    - 如果不需要拷贝，那么将拷贝构造声明为delete
    - 注意delete移动构造（赋值）在C++17的新影响：C++11初始化一个形参时会调用移动构造函数，有delete会出错，C++17开始不会报错，因为不会移动初始化


