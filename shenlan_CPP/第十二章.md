# 第十二章 类的进阶

## 运算符重载

- 使用operator实现运算符重载，引入相应的重载函数
  - 重载不能发明新的运算，不能改变运算的优先级与结合性，通常不改变运算含义
  - 函数参数个数与运算操作数个数相同，至少一个为 类 类型（否则重载没有意义）
  - 除operator（）外其他运算符不能有缺省参数（直接加上一个等于号）（重载小括号）定义在类的成员函数中，可以加缺省，可以包含不确定个参数
  - 可以选择实现为成员函数或非成员函数（可以放到类里面和外面）
    - 通常来说，实现为成员函数时，使用*this作为第一个操作数，注意此时，要少写一个参数，注意 == 与<=>的重载（加法中第二个类型可能会根据public类型进行自动转换，如果是private可能不能自动访问，需要把调用的重载函数定义为友元函数（写在类域的全局域函数））

- 根据重载特性，可以进一步将运算符进行划分：
  - 可重载且必须实现为成员函数的运算符（ =，[], (), ->与转型运算符）
  - 可重载且可以实现为非成员函数的运算符
  - 可重载但不建议重载的运算符（&&， ||，逗号运算符）因为需要分别求值且顺序不定，没办法完全模拟操作过程，C++17开始可以实现，但仍丢失短路逻辑。
  - 不可重载运算符（？：运算符）

- 对称运算符通常定义为非成员函数以支持**首个**操作数的类型转换（另个操作数可以互换，要定义成非成员函数，因为成员函数中的重载第一个操作数一般是*this，也不能硬加一个，否则参数会与操作数不一致）

- 移位运算符一定要定义为非成员函数，因为其首个操作数类型是流类型（<</>>）

  auto& operator << (std::ostream& ostr, Str input) {   } //ostream的引用表示任何一个输出流

- 赋值运算符（必须实现为成员函数）也可以接受一般参数，里面可以不一定是Str类型的参数

- operator[]通常返回引用，这样可以进一步进行写操作（不再是一个右值），但是使用const定义Str类型时会报错，此时应该定义一个函数最后加一个const类型的重载函数，而且不加引用。

- 自增，自减运算符，需要判断是前缀自增（减）还是后缀自增（减）

  后面括号是空，前缀，括号内有一个int型变量，表示是一个后缀自增，此时这个变量没有任何意义

  Str& operator++ () {++val; return *this} //（int val） //qianzhui

  Str operator++ (int) {Str tmp(*this); ++val; return tmp;} //houzhui,返回当前值（构造临时对象会造成一定的性能损失）

- 使用解引用（*）与成员访问运算符（->）（模拟指针行为）

  ```c++
  struct Str
  {
      Str(int* p)
          :ptr(p)
          {}
      int& operator * ()
      {
          return *ptr;
      }
      int operator * () const  //此时只能读不能写，所以也没必要返回一个引用
      {
          return *ptr;
      }
  private:
      int* ptr;
  };
  int main()
  {
      int x = 100;
      Str ptr = &x;
      std::cout << *ptr << std::endl; 
      *ptr = 101 //因为返回int型的引用（不再是右值），所以可以进行赋值
  }  //100
  ```

  - 注意“.”运算符不能重载（.运算符只针对于具体对象）

  - “   ->  "会递归调用“  ->  "操作

    ```c++
    ...
    Str* operator -> ()
        {
            return this;
        }
    int val = 5;
    ...
    std::cout << (ptr->val) << std::endl;  // 5
    std::cout << (ptr.operator->()->val) << std::endl; // 5 第一个箭头也是一个指针，指针再只想一个val
    ```

    ```C++
    struct Str2
    {
        Str2* operator -> ()
        {
            return this;
        }
        int bla = 10;
    };
    ...(Str)
        Str2 operator -> ()
        {
            return Str2{};
        }
    ...(main)
        std::cout << (ptr->bla) << std::endl; //10
    	std::cout << (ptr.operator -> ().operator ->() ->bla) << std::endl; //10 ,第一次返回的是一个Str2类型，第二次返回一个指针类型
    ```

- 使用函数调用运算符构造可调用对象（函数调用的参数是不定的）代替lambda表达式，相比结构体内的function调用更加灵活。

  ```C++
  struct Str
  {
      Str(int p)
      :val(p)
      {}
      int operator() ()
      {
          return val;
      }
      int operator() (int x, int y, int z)
      {
          return val + x + y + z;
      }
  private:
      int val;
  };
  
  int main()
  {
      int x = 100;
      Str ptr = x;
      std::cout << ptr() << std::endl;  //100
      std::cout << ptr(1, 1, 1) << std::endl;  //103   
  }
  ```

- 类型转换运算符的重载

  ```C++
  struct Str
  {
      Str(int p)
      :val(p)
      {}
      operator int() const  //把抽象数据类型（Str）转换为int型，不需显式指定返回值类型
      {
          return val;
      }
  private:
      int val;
  };
  
  int main()
  {
      Str ptr = 100;
      int v = ptr;
      std::cout << v <<std::endl;
  ```

  - 函数声明为 operator type() const
  - 与单参数**构造函数**一样，都引入了一种类型转换的方式
  - 注意避免引入歧义和意料之外的行为（Str类型+int型，是都转换为int还是都转换为str）
    - 通过explicit引入显式类型转换（在前面加上explicit的那个函数，只能显式转换，也就是隐式转换不能走这条路）
  - explicit bool的特殊性：在条件表达式（if括号中，会强制进行转换成bool值）会进行隐式转换

- C++20中对 == 和 <=> 的重载（关系运算符）

  - 通过 ==  定义  != （只定义== 就自动会推导出不等于的重载，但不能反过来）

  - 通过定义 <=>比较多重逻辑（定义的重载不再是bool， 而是 auto 型）

    auto operator <=> (int x) { return val <=> x; } ,此时后续操作可以使用>=/<=/...等四种比较符号，然后也可以左右自动交换，类型也可以隐式转换。

  - 隐式交换操作数（左边是str，右边是int型的时候，对于==会自动交换，否则类型不匹配的时候会报错）

  - 注意 <=>可返回的类型 ： strong_ordering, week_ordering, partial_ordering

## 类的继承

- 通过类的继承（派生）来引入“是一个”的关系

  ```C++
  struct Base
  {
  };
  struct Derive: public Base // public可省，但是class缺省是private继承
  {
  };
  ```

  - 通常采用public继承（struct vs class）

  - 注意：继承部分不是类的声明struct Derive: public Base；这么声明会报错

  - 使用基类的指针或引用可以指向派生类对象

    ```C++
    int main()
    {  
        Derive d;
        Base& ref = d;
        Base* ptr = &d; //没有继承关系不能这么引用、指针
    }
    ```

  - 静态类型 vs 动态类型（上述为d静态类型：编译期就可以读取到的类型，动态类型是运行期确定的类型，后面两者的动态类型是derive）

  - protected限定符（类似于private的那种限定符）：派生类可访问，但是外部不能访问

- 类的派生会形成嵌套域

  - 派生类所在域位于基类内部，所以再定义的变量会覆盖基类中的名称
  - 使用域操作符显式访问基类中的同名变量（base::val）
  - 在派生类中调用基类的**构造函数**  //会先调用基类中的构造函数，再调用派生类的构造函数

