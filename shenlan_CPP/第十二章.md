# 第十二章 类的进阶

## 运算符重载

- 使用operator实现运算符重载，引入相应的重载函数
  - 重载不能发明新的运算，不能改变运算的优先级与结合性，通常不改变运算含义
  - 函数参数个数与运算操作数个数相同，至少一个为 类 类型（否则重载没有意义）
  - 除operator（）外其他运算符不能有缺省参数（直接加上一个等于号）（重载小括号）定义在类的成员函数中，可以加缺省，可以包含不确定个参数
  - 可以选择实现为成员函数或非成员函数（可以放到类里面和外面）
    - 通常来说，实现为成员函数时，使用*this作为第一个操作数，注意此时，要少写一个参数，注意 == 与<=>的重载（加法中第二个类型可能会根据public类型进行自动转换，如果是private可能不能自动访问，需要把调用的重载函数定义为友元函数（写在类域的全局域函数））
- 根据重载特性，可以进一步将运算符进行划分：
  - 可重载且必须实现为成员函数的运算符（ =，[], (), ->与转型运算符）
  - 可重载且可以实现为非成员函数的运算符
  - 可重载但不建议重载的运算符（&&， ||，逗号运算符）因为需要分别求值且顺序不定，没办法完全模拟操作过程，C++17开始可以实现，但仍丢失短路逻辑。
  - 不可重载运算符（？：运算符）

- 对称运算符通常定义为非成员函数以支持**首个**操作数的类型转换（另个操作数可以互换，要定义成非成员函数，因为成员函数中的重载第一个操作数一般是*this，也不能硬加一个，否则参数会与操作数不一致）

- 移位运算符一定要定义为非成员函数，因为其首个操作数类型是流类型（<</>>）

  auto& operator << (std::ostream& ostr, Str input) {   } //ostream的引用表示任何一个输出流

- 赋值运算符（必须实现为成员函数）也可以接受一般参数，里面可以不一定是Str类型的参数

- operator[]通常返回引用，这样可以进一步进行写操作（不再是一个右值），但是使用const定义Str类型时会报错，此时应该定义一个函数最后加一个const类型的重载函数，而且不加引用。

- 自增，自减运算符，需要判断是前缀自增（减）还是后缀自增（减）

  后面括号是空，前缀，括号内有一个int型变量，表示是一个后缀自增，此时这个变量没有任何意义

  Str& operator++ () {++val; return *this} //（int val） //qianzhui

  Str operator++ (int) {Str tmp(*this); ++val;return tmp;} //houzhui,返回当前值（构造临时对象会造成一定的性能损失）

- 



